<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Netflix Killed the Videostore</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      :root {
        --bg-color: #000000;
        --nes-black: #000000;
        --nes-white: #ffffff;
        --nes-red: #ff0000;
        --nes-blue: #2c3e50;
        --nes-gold: #eebb55;
        --nes-menu-blue: #66ccff;
      }

      body {
        background-color: var(--bg-color);
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100vw;
        color: var(--nes-white);
        font-family: "Press Start 2P", cursive;
        overflow: hidden;
        touch-action: none; /* Förhindra scroll/zoom på mobil */
      }

      /* Huvudcontainer för spelet */
      #game-container {
        position: relative;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        border: none;

        /* Grundläggande desktop-storlek */
        height: 80vh;
        aspect-ratio: 4/3;
        max-width: 95vw;
        transition: transform 0.1s; /* För screen shake */
      }

      /* Screen shake klass */
      .shake {
        animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      }

      @keyframes shake {
        10%,
        90% {
          transform: translate3d(-4px, 0, 0);
        }
        20%,
        80% {
          transform: translate3d(6px, 0, 0);
        }
        30%,
        50%,
        70% {
          transform: translate3d(-8px, 0, 0);
        }
        40%,
        60% {
          transform: translate3d(8px, 0, 0);
        }
      }

      canvas {
        display: block;
        image-rendering: pixelated;
        background-color: var(--nes-black);
        width: 100%;
        height: 100%;
      }

      .scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.1) 50%,
          rgba(0, 0, 0, 0.1)
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 10;
        box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5);
      }

      #ui-layer {
        position: absolute;
        top: 10px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 20px;
        box-sizing: border-box;
        z-index: 20;
        text-shadow: 2px 2px #000;
        font-size: 14px;
        pointer-events: none; /* Låt klick gå igenom UI */
      }

      /* --- KONTROLLER --- */
      #controls {
        display: none; /* Dölj på desktop som standard */
        box-sizing: border-box;
        z-index: 100;
      }

      .d-pad {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .btn {
        background: #444;
        border: 3px solid #888;
        color: #fff;
        padding: 20px;
        border-radius: 8px;
        font-family: inherit;
        font-size: 10px;
        user-select: none;
        text-align: center;
        box-shadow: 0 6px 0 #222;
        width: 80px;
        touch-action: manipulation;
      }

      .btn:active {
        box-shadow: 0 0 0 #222;
        transform: translateY(6px);
        background: #555;
      }

      .btn-action {
        background: #e74c3c; /* Röd knapp */
        border-color: #c0392b;
        width: 90px;
        height: 90px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
      }

      /* --- MEDIA QUERIES FÖR RESPONSIVITET --- */

      /* Surfplattor & Mobiler (Visa kontroller) */
      @media (max-width: 1024px), (hover: none) {
        #controls {
          display: flex;
        }
      }

      /* Mobil Porträtt (Stående) */
      @media (orientation: portrait) and (max-width: 1024px) {
        body {
          /* Använd space-between för att trycka ner kontroller och centrera spelet i restytan */
          justify-content: space-between;
          padding-top: 0;
          padding-bottom: 0;
        }

        #game-container {
          width: 95vw;
          height: auto;
          aspect-ratio: 4/3;
          max-height: 50vh; /* Begränsa höjden så det inte krockar med kontroller */

          /* Centrera spelet vertikalt i det övre utrymmet */
          margin-top: auto;
          margin-bottom: auto;
        }

        #controls {
          width: 100%;
          /* Ge kontrollerna ett dedikerat utrymme i botten */
          height: 35vh;
          min-height: 200px;

          /* Tryck ner innehållet mot botten */
          padding: 20px 30px 40px 30px;

          flex-direction: row;
          justify-content: space-between; /* Sprid ut knapparna till kanterna */
          align-items: flex-end; /* Placera knapparna långt ner */

          background: linear-gradient(
            to top,
            rgba(0, 0, 0, 0.8),
            transparent
          ); /* Svag toning för att markera kontrollytan */
          flex-shrink: 0; /* Låt inte detta område krympa */
        }

        /* Justera layout för knapparna i porträtt */
        .d-pad {
          flex-direction: column;
          gap: 20px;
          margin-bottom: 20px; /* Lyft upp lite från den absoluta bottenkanten */
        }

        .btn-action {
          margin-bottom: 30px; /* Justera så den linjerar snyggt med pilarna */
        }

        /* FIX: Copyright ligger nu snyggt under menyn istället för att flyta i botten */
        .copyright {
          position: relative !important;
          bottom: auto !important;
          margin-top: 30px;
          width: auto;
        }
      }

      /* Mobil Landskap (Liggande) - "Game Boy" Style */
      @media (orientation: landscape) and (max-height: 800px) {
        body {
          flex-direction: row; /* Sätt saker bredvid varandra */
          justify-content: center;
          align-items: center;
        }

        #game-container {
          height: 90vh; /* Fyll höjden */
          width: auto;
          aspect-ratio: 4/3;
          /* Se till att den inte täcker hela bredden så kontrollerna får plats */
          max-width: 65vw;
        }

        #controls {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none; /* Låt klick gå igenom tomma ytor */

          justify-content: space-between; /* Sprid ut knapparna */
          align-items: flex-end; /* Lägg dem i botten */
          padding: 20px 5vw; /* Marginal från kanten */
        }

        .d-pad,
        .btn-action {
          pointer-events: auto; /* Aktivera knapparna */
        }

        .d-pad {
          margin-bottom: 20px;
        }
        .btn-action {
          margin-bottom: 40px;
        }
      }

      /* --- UI STYLING --- */

      #start-screen,
      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; /* Centrera bättre på mobil */
        padding-top: 0; /* Ta bort top padding för bättre centrering */
        z-index: 30;
        text-align: center;
        box-sizing: border-box;
      }

      /* Top Score style - Matchar Wild Gunman */
      #start-top-score {
        color: #ffffff; /* Vit text som i originalet */
        font-size: 2.2vh;
        margin-top: 5vh; /* Lite mer avstånd från menyn */
        margin-bottom: 2vh;
        text-shadow: 2px 2px #000;
        text-transform: uppercase;
      }

      h1 {
        color: #eebb55;
        font-size: 3.5vh; /* Responsiv textstorlek */
        line-height: 1.4;
        margin-bottom: 4vh;
        text-shadow: 4px 4px 0px #8b4513, 6px 6px 0px #000;
        text-transform: uppercase;
      }

      .title-netflix {
        color: #e50914 !important;
        text-shadow: 3px 3px 0px #500000, 5px 5px 0px #000 !important;
      }

      .title-blockbuster {
        color: #eebb55 !important;
        text-shadow: 3px 3px 0px #003399, 5px 5px 0px #000 !important;
      }

      #menu-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        margin-bottom: 20px;
      }

      .menu-item {
        font-size: 2.2vh;
        color: var(--nes-menu-blue); /* Wild Gunman ljusblå */
        margin-bottom: 2vh;
        padding: 10px;
        cursor: pointer;
        text-shadow: 2px 2px #000;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 10px;
        text-decoration: none;
        user-select: none;
      }

      .menu-item.selected {
        color: #ffffff; /* Vit när vald (eller gul om man vill) */
      }

      .copyright {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
        color: var(--nes-gold); /* Guld/Beige som i Wild Gunman */
        font-size: 10px;
        text-shadow: 2px 2px #000;
      }

      .cursor-icon {
        width: 20px;
        height: 12px;
        display: inline-block;
        position: relative;
        margin-right: 10px;
        visibility: hidden;
        background: #333;
        border: 1px solid #fff;
      }

      .menu-item.selected .cursor-icon {
        visibility: visible;
      }

      .cursor-icon::after,
      .cursor-icon::before {
        content: "";
        position: absolute;
        background: #fff;
        width: 4px;
        height: 4px;
        border-radius: 50%;
      }
      .cursor-icon::after {
        top: 2px;
        left: 2px;
      }
      .cursor-icon::before {
        top: 2px;
        right: 2px;
      }

      p {
        font-size: 2vh;
        color: #ccc;
        line-height: 1.8;
        margin-bottom: 30px;
        max-width: 80%;
      }

      .blink {
        animation: blinker 1s linear infinite;
        color: #f1c40f;
        cursor: pointer;
        font-size: 2.5vh;
        margin-top: 20px;
        padding: 20px; /* Större klickyta */
      }

      @keyframes blinker {
        50% {
          opacity: 0;
        }
      }

      #high-score-display {
        color: #f1c40f;
        text-shadow: 1px 1px 0 #000;
      }

      #level-display {
        color: #fff;
        text-shadow: 1px 1px 0 #000;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="gameCanvas" width="640" height="480"></canvas>
      <div class="scanlines"></div>

      <div id="ui-layer">
        <div id="score-display">POÄNG: 0</div>
        <div id="level-display">NIVÅ: 1</div>
        <div id="high-score-display">HI: 0</div>
        <div id="lives-display">LIV: VHS VHS VHS</div>
      </div>

      <div id="start-screen">
        <h1>
          <span class="title-netflix">NETFLIX KILLED</span><br />
          <span class="title-blockbuster">THE VIDEOSTORE</span>
        </h1>

        <div id="menu-container">
          <!-- Lade till ontouchstart för snabb respons på mobil -->
          <div
            class="menu-item selected"
            onclick="startGame('normal')"
            ontouchstart="startGame('normal')"
            onmouseenter="selectMenu(this)"
          >
            <div class="cursor-icon"></div>
            GAME A (NORMAL)
          </div>
          <div
            class="menu-item"
            onclick="startGame('hard')"
            ontouchstart="startGame('hard')"
            onmouseenter="selectMenu(this)"
          >
            <div class="cursor-icon"></div>
            GAME B (HARD)
          </div>
        </div>

        <div id="start-top-score">TOP SCORE - 0</div>

        <div class="copyright">&copy;1984 VIDEOSTORE</div>
      </div>

      <div id="game-over-screen" style="display: none">
        <h1 style="color: #888">BUTIKEN STÄNGD</h1>
        <p id="final-score">SLUTPOÄNG: 0</p>
        <p style="color: #e74c3c">STREAMING TOG ÖVER...</p>
        <!-- Lade till ontouchstart här med -->
        <div class="blink" onclick="goToTitle()" ontouchstart="goToTitle()">
          TILL TITELSKÄRM
        </div>
      </div>
    </div>

    <div id="controls">
      <div class="d-pad">
        <div class="btn" id="btn-up">UPP</div>
        <div class="btn" id="btn-down">NER</div>
      </div>
      <div class="btn btn-action" id="btn-throw">VHS</div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score-display");
      const levelEl = document.getElementById("level-display");
      const livesEl = document.getElementById("lives-display");
      const highScoreEl = document.getElementById("high-score-display");
      const startTopScoreEl = document.getElementById("start-top-score");
      const startScreen = document.getElementById("start-screen");
      const gameOverScreen = document.getElementById("game-over-screen");
      const finalScoreEl = document.getElementById("final-score");
      const gameContainer = document.getElementById("game-container");

      const LANES = 4;
      const LANE_HEIGHT = 85;
      const LANE_START_Y = 130;
      const PLAYER_X = 550;
      const TAP_X = 510;

      let gameLoopId;
      let frameCount = 0;
      let score = 0;
      let level = 1;
      let highScore = localStorage.getItem("vhs_highscore") || 0;
      let lives = 3;
      let isGameOver = false;
      let gameSpeed = 1;
      let difficultyMultiplier = 1;
      let baseDifficulty = 1;
      let gameOverTimeout;

      // Level transition
      let isLevelTransition = false;
      let transitionTimer = 0;
      const LEVEL_THRESHOLDS = [1000, 3000]; // Poänggränser för Nivå 2 och 3

      // Attract Mode Variabler
      let isAttractMode = false;
      let attractTimer;
      let aiCooldown = 0;

      let comboCount = 0;
      let lastHitTime = 0;

      const AudioContext = window.AudioContext || window.webkitAudioContext;
      const audioCtx = new AudioContext();

      let player = {
        lane: 1,
        visualLane: 1,
        cooldown: 0,
        throwAnim: 0,
        isMoving: false,
      };

      let customers = [];
      let tapes = [];
      let particles = [];
      let scoreFloaters = [];

      highScoreEl.innerText = "HI: " + highScore;
      startTopScoreEl.innerText = "TOP SCORE - " + highScore;

      // DEFINIERA FUNKTIONER SOM VANLIGA FUNKTIONER FÖRST (HOISTING)

      function selectMenu(element) {
        document
          .querySelectorAll(".menu-item")
          .forEach((el) => el.classList.remove("selected"));
        element.classList.add("selected");
      }

      function startGame(mode) {
        if (isAttractMode) interruptAttractMode();
        if (attractTimer) clearTimeout(attractTimer);

        startScreen.style.display = "none";

        if (gameOverTimeout) clearTimeout(gameOverTimeout);

        if (mode === "hard") {
          baseDifficulty = 1.5;
        } else {
          baseDifficulty = 1.0;
        }

        resetGameVars();
        gameLoop();
      }

      function goToTitle() {
        if (gameOverTimeout) clearTimeout(gameOverTimeout);

        gameOverScreen.style.display = "none";
        startScreen.style.display = "flex";
        startTopScoreEl.innerText = "TOP SCORE - " + highScore;

        // Återstarta attract timer
        startAttractTimer();
      }

      function drawSprite(ctx, type, x, y, options = {}) {
        const p = 4;

        if (type === "player") {
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.beginPath();
          ctx.ellipse(x + p * 4, y + p * 3, p * 6, p * 2, 0, 0, Math.PI * 2);
          ctx.fill();

          const isMoving = options.isMoving;
          const runAnim = Math.floor(Date.now() / 100) % 2;

          ctx.fillStyle = "#000";
          if (isMoving && runAnim === 0) {
            ctx.fillRect(x + p, y - p, p * 2, p * 4);
            ctx.fillRect(x + p * 5, y, p * 2, p * 3);
          } else if (isMoving && runAnim === 1) {
            ctx.fillRect(x + p, y, p * 2, p * 3);
            ctx.fillRect(x + p * 5, y - p, p * 2, p * 4);
          } else {
            ctx.fillRect(x + p, y, p * 2, p * 3);
            ctx.fillRect(x + p * 5, y, p * 2, p * 3);
          }

          ctx.fillStyle = "#fff";
          ctx.fillRect(x, y - p * 6, p * 8, p * 6);
          ctx.fillStyle = "#3498db";
          ctx.fillRect(x, y - p * 6, p * 2, p * 6);
          ctx.fillRect(x + p * 6, y - p * 6, p * 2, p * 6);

          ctx.fillStyle = "#ffccaa";
          ctx.fillRect(x + p, y - p * 10, p * 6, p * 4);

          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(x + p, y - p * 11, p * 6, p * 1);
          ctx.fillRect(x + p * 6, y - p * 10, p * 2, p * 2);

          ctx.fillStyle = "#ffccaa";
          if (options.throwing > 0) {
            ctx.fillRect(x - p * 4, y - p * 5, p * 5, p * 2);
          } else {
            ctx.fillRect(x + p * 2, y - p * 2, p * 4, p * 4);
          }
        } else if (type === "customer") {
          const color = options.color || "#e74c3c";
          const frame = Math.floor(Date.now() / 200) % 2;

          ctx.fillStyle = "#111";
          if (frame === 0) {
            ctx.fillRect(x + p, y, p * 2, p * 3);
            ctx.fillRect(x + p * 5, y, p * 2, p * 3);
          } else {
            ctx.fillRect(x, y, p * 2, p * 3);
            ctx.fillRect(x + p * 4, y, p * 2, p * 3);
          }

          ctx.fillStyle = color;
          ctx.fillRect(x, y - p * 6, p * 8, p * 6);
          ctx.fillStyle = "rgba(0,0,0,0.2)";
          ctx.fillRect(x, y - p * 4, p * 8, p * 1);

          ctx.fillStyle = "#ffeebb";
          ctx.fillRect(x + p, y - p * 10, p * 6, p * 4);

          ctx.fillStyle = "#555";
          if (color === "#f1c40f") ctx.fillStyle = "#e67e22";
          if (color === "#2ecc71") ctx.fillStyle = "#000";

          ctx.fillRect(x + p, y - p * 11, p * 6, p * 2);
          ctx.fillRect(x + p, y - p * 10, p * 1, p * 3);

          ctx.fillStyle = "#000";
          ctx.fillRect(x + p * 2, y - p * 8, p * 4, p * 1);
        } else if (type === "tape") {
          ctx.fillStyle = "#111";
          ctx.fillRect(x, y - 20, 24, 14);
          ctx.fillStyle = "#ddd";
          ctx.fillRect(x + 2, y - 18, 14, 10);
          ctx.fillStyle = "#fff";
          ctx.fillRect(x + 4, y - 16, 4, 4);
          ctx.fillRect(x + 10, y - 16, 4, 4);
        } else if (type === "shelf") {
          const bookWidth = 6;
          const bookGap = 2;

          for (let i = 0; i < 640; i += bookWidth + bookGap) {
            const seed = (x + i + y) * 123;
            const r = Math.floor((Math.sin(seed) + 1) * 128);
            const g = Math.floor((Math.cos(seed) + 1) * 128);
            const b = Math.floor((Math.sin(seed * 2) + 1) * 128);

            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(x + i, y - 20, bookWidth, 20);

            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.fillRect(x + i + bookWidth - 1, y - 20, 1, 20);
          }
        }
      }

      function drawBrickWall(ctx) {
        // Ändra bakgrundsfärg beroende på nivå
        let bgColor = "#2c0e0e"; // Default Nivå 1 (Röd)
        let brickColor = "#3e1a1a";

        if (level === 2) {
          bgColor = "#1a1a3e"; // Nivå 2 (Blå/Industriell)
          brickColor = "#2a2a4e";
        } else if (level >= 3) {
          bgColor = "#1a3e1a"; // Nivå 3 (Grön/Toxic)
          brickColor = "#2a4e2a";
        }

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, 640, 480);

        ctx.fillStyle = brickColor;
        const brickW = 40;
        const brickH = 20;

        for (let row = 0; row < 24; row++) {
          const offset = (row % 2) * (brickW / 2);
          for (let col = -1; col < 17; col++) {
            ctx.fillRect(
              col * brickW + offset + 2,
              row * brickH + 2,
              brickW - 4,
              brickH - 4
            );
          }
        }
      }

      function drawTV(ctx, x, y) {
        ctx.fillStyle = "#111";
        ctx.fillRect(x, y, 60, 50);
        ctx.fillStyle = "#444";
        ctx.fillRect(x + 2, y + 2, 56, 46);

        ctx.fillStyle = "#000";
        ctx.fillRect(x + 4, y + 4, 44, 42);

        ctx.fillStyle = "#222";
        ctx.fillRect(x + 50, y + 8, 6, 6);
        ctx.fillRect(x + 50, y + 18, 6, 6);

        for (let i = 0; i < 50; i++) {
          const nx = x + 4 + Math.random() * 44;
          const ny = y + 4 + Math.random() * 42;
          const shade = Math.random() * 255;
          ctx.fillStyle = `rgba(${shade},${shade},${shade}, 0.8)`;
          ctx.fillRect(nx, ny, 2, 2);
        }

        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath();
        ctx.moveTo(x + 4, y + 4);
        ctx.lineTo(x + 20, y + 4);
        ctx.lineTo(x + 4, y + 20);
        ctx.fill();
      }

      function spawnScore(x, y, text) {
        scoreFloaters.push({
          x: x,
          y: y,
          text: text,
          life: 60,
        });
      }

      function playSound(type) {
        if (isAttractMode || audioCtx.state === "suspended") {
          if (!isAttractMode) audioCtx.resume();
          if (isAttractMode) return;
        }

        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (type === "throw") {
          osc.type = "square";
          osc.frequency.setValueAtTime(400, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            100,
            audioCtx.currentTime + 0.1
          );
          gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === "hit") {
          osc.type = "sawtooth";
          const pitch = 200 + comboCount * 50;
          osc.frequency.setValueAtTime(pitch, audioCtx.currentTime);
          osc.frequency.linearRampToValueAtTime(
            pitch + 400,
            audioCtx.currentTime + 0.1
          );
          gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        } else if (type === "crash") {
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(100, audioCtx.currentTime);
          osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
          gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.3);
        } else if (type === "levelup") {
          // Fanfar för Level Up
          osc.type = "square";
          osc.frequency.setValueAtTime(400, audioCtx.currentTime);
          osc.frequency.setValueAtTime(500, audioCtx.currentTime + 0.1);
          osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.2);
          osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.4);
          gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.8);
        }
      }

      function shakeScreen() {
        if (isAttractMode) return;
        gameContainer.classList.add("shake");
        setTimeout(() => {
          gameContainer.classList.remove("shake");
        }, 500);
      }

      function spawnCustomer() {
        const lane = Math.floor(Math.random() * LANES);
        const customersInLane = customers.filter((c) => c.lane === lane).length;
        if (customersInLane > 2) return;

        const colors = ["#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6"];
        customers.push({
          lane: lane,
          x: 20,
          speed: (0.5 + Math.random() * 0.5) * difficultyMultiplier,
          color: colors[Math.floor(Math.random() * colors.length)],
          pushedBack: 0,
        });
      }

      function createExplosion(x, y) {
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: x,
            y: y - 25,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            life: 20,
            color: "#fff",
          });
        }
      }

      function startAttractTimer() {
        if (attractTimer) clearTimeout(attractTimer);
        attractTimer = setTimeout(startAttractMode, 5000);
      }

      function startAttractMode() {
        isAttractMode = true;
        startScreen.style.display = "none";
        resetGameVars();
        gameLoop();
      }

      function interruptAttractMode() {
        if (isAttractMode) {
          isAttractMode = false;
          isGameOver = true; // Stoppa loopen
          cancelAnimationFrame(gameLoopId);
          goToTitle();
        }
      }

      function startLevelTransition(newLevel) {
        level = newLevel;
        isLevelTransition = true;
        transitionTimer = 180; // 3 sekunder (vid 60fps)
        playSound("levelup");

        // Rensa existerande kunder för en "fresh start" på nya nivån
        customers = [];
        tapes = [];
        player.lane = 1;
        player.visualLane = 1;
        updateUI();
      }

      function update() {
        if (isGameOver) return;

        // Pausa spelet under level transition
        if (isLevelTransition) {
          transitionTimer--;
          if (transitionTimer <= 0) {
            isLevelTransition = false;
          }
          // Rita bara (via game loop) men uppdatera inte logik
          return;
        }

        frameCount++;

        if (isAttractMode) {
          if (aiCooldown > 0) aiCooldown--;

          let targetCustomer = null;
          let maxX = -1;

          customers.forEach((c) => {
            if (c.pushedBack <= 0 && c.x > maxX) {
              maxX = c.x;
              targetCustomer = c;
            }
          });

          if (targetCustomer) {
            if (player.lane < targetCustomer.lane && aiCooldown === 0) {
              player.lane++;
              aiCooldown = 10;
            } else if (player.lane > targetCustomer.lane && aiCooldown === 0) {
              player.lane--;
              aiCooldown = 10;
            } else if (player.lane === targetCustomer.lane) {
              if (Math.random() < 0.1 && player.cooldown === 0) {
                throwTape();
              }
            }
          }
        } else {
          // Level Up Check (Endast i vanligt spel)
          if (level === 1 && score >= LEVEL_THRESHOLDS[0]) {
            startLevelTransition(2);
          } else if (level === 2 && score >= LEVEL_THRESHOLDS[1]) {
            startLevelTransition(3);
          }
        }

        difficultyMultiplier = baseDifficulty + score / 500;

        let spawnRate = Math.max(40, 180 / baseDifficulty - score / 10);
        if (frameCount % Math.floor(spawnRate) === 0) {
          spawnCustomer();
        }

        if (Date.now() - lastHitTime > 2000) {
          comboCount = 0;
        }

        const speed = 0.2;
        const diff = player.lane - player.visualLane;

        if (Math.abs(diff) > 0.05) {
          player.visualLane += Math.sign(diff) * speed;
          player.isMoving = true;
        } else {
          player.visualLane = player.lane;
          player.isMoving = false;
        }

        if (player.cooldown > 0) player.cooldown--;
        if (player.throwAnim > 0) player.throwAnim--;

        for (let i = tapes.length - 1; i >= 0; i--) {
          let t = tapes[i];
          t.x -= 6;

          if (t.x < 10) {
            tapes.splice(i, 1);
            if (!isAttractMode) {
              lives--;
              comboCount = 0;
              shakeScreen();
              playSound("crash");
              checkGameOver();
            }
            createExplosion(20, LANE_START_Y + t.lane * LANE_HEIGHT + 40);
          }
        }

        for (let i = customers.length - 1; i >= 0; i--) {
          let c = customers[i];

          if (c.pushedBack > 0) {
            c.x -= 6;
            c.pushedBack -= 6;

            if (c.x < -20) {
              customers.splice(i, 1);
              score += 50;
              spawnScore(20, LANE_START_Y + c.lane * LANE_HEIGHT + 20, "50");
              continue;
            }
          } else {
            c.x += c.speed;
          }

          if (c.x > TAP_X - 20) {
            if (isAttractMode) {
              isGameOver = true;
              goToTitle();
            } else {
              lives = 0;
              shakeScreen();
              checkGameOver();
            }
          }
        }

        tapes.forEach((t, tIndex) => {
          customers.forEach((c, cIndex) => {
            if (t.lane === c.lane && !t.dead) {
              if (t.x < c.x + 20 && t.x > c.x - 10) {
                if (c.pushedBack > 0) {
                  t.dead = true;
                  playSound("hit");
                  createExplosion(
                    c.x,
                    LANE_START_Y + c.lane * LANE_HEIGHT + 40
                  );
                } else {
                  playSound("hit");
                  t.dead = true;

                  c.pushedBack = c.x + 100;

                  comboCount++;
                  lastHitTime = Date.now();
                  let comboBonus = comboCount > 1 ? comboCount * 10 : 0;

                  score += 10 + comboBonus;

                  let scoreText = "10";
                  if (comboBonus > 0)
                    scoreText += " +" + comboBonus + " COMBO!";

                  spawnScore(
                    c.x,
                    LANE_START_Y + c.lane * LANE_HEIGHT,
                    scoreText
                  );
                  createExplosion(
                    c.x,
                    LANE_START_Y + c.lane * LANE_HEIGHT + 40
                  );
                }
              }
            }
          });
        });

        tapes = tapes.filter((t) => !t.dead);

        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = scoreFloaters.length - 1; i >= 0; i--) {
          let sf = scoreFloaters[i];
          sf.y -= 1;
          sf.life--;
          if (sf.life <= 0) scoreFloaters.splice(i, 1);
        }

        updateUI();
      }

      function draw() {
        drawBrickWall(ctx);

        for (let r = 0; r < 8; r++) {
          for (let c = 0; c < 10; c++) {
            ctx.fillStyle = (r + c) % 2 === 0 ? "#2c3e50" : "#34495e";
            ctx.fillRect(c * 64, r * 60, 64, 60);
          }
        }

        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, 640, 80);

        ctx.fillStyle = "#ffd700";
        ctx.fillRect(198, 18, 244, 54);
        ctx.fillStyle = "#000";
        ctx.fillRect(200, 20, 240, 50);

        ctx.fillStyle = "#e74c3c";
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText("NETFLIX", 290, 40);
        ctx.fillStyle = "#fff";
        ctx.fillText("COMING SOON...", 270, 55);

        drawTV(ctx, 500, 15);

        for (let i = 0; i < LANES; i++) {
          const y = LANE_START_Y + i * LANE_HEIGHT;

          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0, y - 35, 640, 20);
          drawSprite(ctx, "shelf", 0, y - 35);

          ctx.fillStyle = "#9b59b6";
          ctx.fillRect(0, y, 640, 4);
          ctx.fillStyle = "#8e44ad";
          ctx.fillRect(0, y + 4, 640, 8);

          ctx.fillStyle = "#f39c12";
          ctx.fillRect(TAP_X, y, 12, 40);
          ctx.fillStyle = "#000";
          ctx.fillRect(TAP_X + 2, y + 10, 8, 20);

          ctx.fillStyle = "#444";
          ctx.fillRect(0, y - 50, 25, 60);
          ctx.fillStyle = "#111";
          ctx.fillRect(2, y - 48, 21, 58);

          const blink = Math.floor(Date.now() / 500) % 2 === 0;
          ctx.fillStyle = blink ? "#00ff00" : "#003300";
          ctx.fillRect(2, y - 60, 21, 10);

          ctx.fillStyle = blink ? "#fff" : "#888";
          ctx.font = "8px monospace";
          ctx.fillText("UT", 6, y - 52);
        }

        customers.sort((a, b) => a.lane - b.lane);
        customers.forEach((c) => {
          const y = LANE_START_Y + c.lane * LANE_HEIGHT + 40;
          drawSprite(ctx, "customer", c.x, y, { color: c.color });
        });

        tapes.forEach((t) => {
          const y = LANE_START_Y + t.lane * LANE_HEIGHT + 40;
          drawSprite(ctx, "tape", t.x, y);
        });

        const playerY = LANE_START_Y + player.visualLane * LANE_HEIGHT + 40;
        drawSprite(ctx, "player", PLAYER_X, playerY, {
          throwing: player.throwAnim,
          isMoving: player.isMoving,
        });

        particles.forEach((p) => {
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, 4, 4);
        });

        scoreFloaters.forEach((sf) => {
          ctx.fillStyle = "#fff";
          ctx.font = '10px "Press Start 2P"';
          ctx.fillText(sf.text, sf.x, sf.y);
        });

        if (isAttractMode) {
          const blink = Math.floor(Date.now() / 800) % 2 === 0;
          if (blink) {
            ctx.fillStyle = "#ffffff";
            ctx.font = '20px "Press Start 2P"';
            ctx.fillText("DEMO PLAY", 240, 240);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.strokeText("DEMO PLAY", 240, 240);
          }
        }

        // Rita Level Transition Text
        if (isLevelTransition) {
          const blink = Math.floor(Date.now() / 200) % 2 === 0;
          if (blink) {
            ctx.fillStyle = "#f1c40f";
            ctx.font = '30px "Press Start 2P"';
            ctx.fillText("NIVÅ " + level, 240, 240);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText("NIVÅ " + level, 240, 240);
          }
        }
      }

      function checkGameOver() {
        if (lives <= 0) {
          isGameOver = true;
          lives = 0;

          if (score > highScore) {
            highScore = score;
            localStorage.setItem("vhs_highscore", highScore);
          }

          updateUI();
          finalScoreEl.innerText = "SLUTPOÄNG: " + score;
          gameOverScreen.style.display = "flex";
          playSound("crash");

          if (gameOverTimeout) clearTimeout(gameOverTimeout);
          gameOverTimeout = setTimeout(goToTitle, 15000);
        }
      }

      function updateUI() {
        scoreEl.innerText = "POÄNG: " + score;
        levelEl.innerText = "NIVÅ: " + level;
        highScoreEl.innerText = "HI: " + highScore;
        let heartStr = "";
        for (let i = 0; i < lives; i++) heartStr += " [VHS]";
        livesEl.innerText = "LIV:" + heartStr;
      }

      function movePlayer(dir) {
        if (isAttractMode) {
          interruptAttractMode();
          return;
        }
        if (isGameOver || isLevelTransition) return;

        const oldLane = player.lane;
        player.lane += dir;
        if (player.lane < 0) player.lane = 0;
        if (player.lane >= LANES) player.lane = LANES - 1;
      }

      function throwTape() {
        if (isAttractMode && !isGameOver) {
          player.cooldown = 15;
          player.throwAnim = 10;
          playSound("throw");
          tapes.push({
            lane: player.lane,
            x: PLAYER_X - 10,
            dead: false,
          });
          return;
        }

        if (isAttractMode) {
          interruptAttractMode();
          return;
        }

        if (isGameOver || isLevelTransition) return;
        if (player.isMoving) return;

        if (player.cooldown > 0) return;

        player.cooldown = 15;
        player.throwAnim = 10;
        playSound("throw");

        tapes.push({
          lane: player.lane,
          x: PLAYER_X - 10,
          dead: false,
        });
      }

      function resetGameVars() {
        score = 0;
        lives = 3;
        level = 1;
        comboCount = 0;
        isGameOver = false;
        isLevelTransition = false;
        customers = [];
        tapes = [];
        player.lane = 1;
        player.visualLane = 1;
        player.isMoving = false;
        frameCount = 0;
        scoreFloaters = [];
        aiCooldown = 0;

        if (!isAttractMode && audioCtx.state === "suspended") {
          audioCtx.resume();
        }
      }

      function gameLoop() {
        if (!isGameOver) {
          update();
          draw();
          gameLoopId = requestAnimationFrame(gameLoop);
        }
      }

      window.addEventListener("keydown", (e) => {
        if (isAttractMode) {
          interruptAttractMode();
          return;
        }
        if (e.code === "ArrowUp") movePlayer(-1);
        if (e.code === "ArrowDown") movePlayer(1);
        if (e.code === "Space") throwTape();
      });

      document.getElementById("btn-up").addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (isAttractMode) {
          interruptAttractMode();
          return;
        }
        movePlayer(-1);
      });
      document
        .getElementById("btn-down")
        .addEventListener("touchstart", (e) => {
          e.preventDefault();
          if (isAttractMode) {
            interruptAttractMode();
            return;
          }
          movePlayer(1);
        });
      document
        .getElementById("btn-throw")
        .addEventListener("touchstart", (e) => {
          e.preventDefault();
          if (isAttractMode) {
            interruptAttractMode();
            return;
          }
          throwTape();
        });

      document.body.addEventListener("click", (e) => {
        if (isAttractMode) interruptAttractMode();
      });

      // KOPPLA FUNKTIONER TILL WINDOW PÅ SLUTET FÖR ATT VARA SÄKER
      window.selectMenu = selectMenu;
      window.startGame = startGame;
      window.goToTitle = goToTitle;

      draw();
      startAttractTimer(); // Se till att timern startar vid laddning
    </script>
  </body>
</html>
